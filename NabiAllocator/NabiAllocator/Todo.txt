This project is my dissertation! (hopefully...)

Resources:
* Videos / Lectures
- "What does it take to design a memory allocator?" https://www.youtube.com/watch?v=UTii4dyhR5c (+ the playlist)
- "Introduction to General Purpose Allocation" https://youtu.be/MvDUe2evkHg?feature=shared (+ the playlist)
- "Parallelizing the Naughty Dog Engine" https://www.gdcvault.com/play/1022186/Parallelizing-the-Naughty-Dog-Engine (the memory part of this)

* Articles
- "Writing a memory allocator" http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/
- "Writing your own memory allocator" https://screwjankgames.github.io/engine%20programming/2020/09/24/writing-your-own-memory-allocators.html
- "C++: Custom memory allocation" https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/
- "Building a Low Fragmentation Memory Allocator" https://www.gdcvault.com/play/1023005/Building-a-Low-Fragmentation-Memory

* Other
- Profiling: https://learn.microsoft.com/en-us/visualstudio/profiling/profiling-feature-tour?view=vs-2022
- If we need to access the private members of a class for testing, see this: https://stackoverflow.com/a/23267346/8890269

Notes:
- A large block of memory should be allocated when the program starts using malloc (and this should be the only malloc made) this 
  large block of memory is managed by a global allocator (for example a stack allocator). Each subsystem should then allocate the block of
  memory it needs to work from the global allocator, and create allocators that will manage that memory.
	- From the gamedev.net article. Looks like we need a basic allocator as well? We were already going to make an unmanagedalloctor 
	  (just a wrapper around malloc/free) - but we might need something else below this?
	- The heap zone parent stuff will allow for this elegantly 
	- We can also mention this design structure in the dis

- Note the final comment about no debug heap
	- https://stackoverflow.com/questions/13064850/malloc-vs-custom-allocator-malloc-has-a-lot-of-overhead-why
	- also /FA or debugger output to view generated assembly

Tasks:

*Long Term
- Make NabiAllocator a single header (or single .h+.inl+.cpp...) library once it's finished. This will make it easier to export / other people to benchmark.
- Bump the version to 1.0! (Core/Inc/Version.h)

- Profile the use of __forceinline on: (i have never used forceinline before, so it will be interesting to see)
	- BitOperations
	- MemoryOperations
	- HeapZone -> Allocate/Free

- Make sure you test running with defines on / off and x64/86 etc. All combinations before submission!

- Write a python script to display the memory layout as eg a pie chart (free vs allocated blocks).
	- Is the projects folder structure ok to put this stuff in a place which makes sense?
	- Also a script to graph out the different allocator's performance? (malloc/free/total vs) (+ vs default malloc)

- Remember C:\Users\Ben\Desktop\Uni\Year 3\Dissertation -> Lots of good stuff in here for the writeup

- Something to investigate / understand is virtual memory in the context of - when the OS gives memory to an application it gives it in a way
  that every application thinks it has a block going from 0 -> end..? perhaps..? can this memory be non contigous? eg the application thinks it
  is but in reality its not?

- “The value of TS should be large enough to allow a sufficient number of different tag values (i.e. at least 4 to provide ~ 16 tag values) and
   small enough to fit into the unused upper bits of a pointer (usually up to 8 or 16, depending on the architecture). TS also affects the 
   complexity and the size of the tag storage.” This is how we have zero byte tagging! Combined with Molly Rocket’s video on seeing if memory 
   is used.. This could be really interesting. Find that video on pointer buckets.

*General
- Then we need to learn how to profile and optimise what we have as much as we can!
	- Apperently the TryCoalesceBlock function is the slowest now. It has some futher function calls in it though, and I can't see exactly what I can push futher right now.

- Make the allocations thread safe? std::scoped_lock in HeapZone alloc/free?
- Gotta find somewhere we can wack a goto in our code... :D

- Make sure there is a default allocator that just uses malloc/free, not even a heap zone. have a heap zone scope for this
- We also need a stack allocator / linear allocator. something basic just to be the parent of the other allocators

- If I manually free memory, do i need to call that memory's destructor?
	- YES! you do [maybe???]. In eg ReleaseMemoryToOS you can do memory->~T();
	- What about memorys constructor?
	- Think about the best place to do this. Would it be in ReleaseMemoryToOS and HeapZone->Free? Then RequestMemoryFromOS and HeapZone->Allocate..?
		- With constructors, would we have to perfect forward the constructors arguements?

- Lower case folder names? 

- do the test blueprints need the extra namespace as well..? [i think these should stay..?]

- std::optional<std::function>>> *const*? <-?? wtf is this?
- use NA_WRAP where we are doing \" \" atm?
- Should my local std::function definitions be const? [like in AllocatorUtils.inl] and std::functions being passed into functions?
- Allocate/Free multiple test?  in default tests?

- Test for memory tag scopes / heap zone changing. (Unless this is handled in MemoryCommand? Add the test there if not) [WIP]
	- This is WIP, we need the unmanaged allocator

- About time we make the unmanaged allocator/heap zone i recon. this is needed for some tests and just generally

- And then start bringing it all together with the new/delete operator overrides. Then all these other todos and python utils!
- We also have some ctrl+f todods
- Should block headers / footers / other stuff be [header/footer] const* const? (where they can - check!)
- Ops on inlinging some of MemoryCommand's functions?

- find if things have been overriden by checksums [ask brandon]

- Is the custom memory command actually a valid piece of logic? BEcause if NA_OVERRIDE_NEW_DELETE is not enabled, then we actually have to use it
  If we decide it is, can remove the comments saying the logic is bot in heapzonescope (top comment and next to the var itself) (and other places..?)

- can we assert if through the memory command we make an allocation too big? it just seems to crash atm

- I think we have a todo above, but we need to make sure our implemenation still calls consturctors / destructors.
- I think this needs to be done for when we default malloc/free as well [actually, maybe not?]

- see this for proper new/delete replacement
  https://stackoverflow.com/questions/4134195/how-do-i-call-the-original-operator-new-if-i-have-overloaded-it

- If we change the default allocation in the memory command to eg a pre created heap zone, then change the notes comment
   "Static allocations will happen through the default allocation path, set as std::malloc/std::free."
		- I think the unmanaged heap will have to be set up by the user, cos otherwise we will have some static variabls allocated there and others just by cpp
	    -  We can just have a macro called like NA_SETUP / NA_DEFAULT_SETUP in a new config file, and they will set up an unmanaged heap and a statck/free list alloc on atop?

- Should the memory command be thread local?
	- Perhaps this is something to test/benchmark
		- implement a macro like NA_THREAD_LOCAL_SINGLETON static MemoryCommand* ThreadLocalGet() {
			thread_local MemoryCommand d;
			return &d;
		}
	- I think there is a gap in my understanding here, research more

- In the memory command, is the way we are routing to the default malloc/free most optimimal? (and just the general routing to the heap zone i guess..)
- In the memory command, I'm using [[likely]] & [[unlikely]] in the implementation... thoughts on their usage?
	- If we remove them or decide 100% then remove the questionging comment in notes.
	- **I think this is something we could benchmark and then write about on dis..?**

- Python ultities
- ^ These are the focus rn. Get the project into a submittable state!

Archive:
- Annotate the MemoryCommand::Allocate/Free if checks with likely and unlikely as well?
- Should NA_IMPLEMENT_SINGLETON return a reference not a pointer? static Type t; return t; not &? research
- NA_HEAP_ZONE_SCOPE -> NA_SET_HEAP_ZONE_SCOPE? (if so, update this in tests and hint file)
- take free list allocator / stack allocator out of there namespaces? its a little clunky i think...
- A macro to make the NA_CONCAT(NA_XSTR(NA_BENCHMARK_IDENTIFIER), NA_GTEST_FILTER_SEPERATOR) stuff in main.cpp one thing? (we call this code 3 times)
- Same deal for test constant's NA_CONCAT(NA_EXPAND(NA_TEST_IDENTIFIER), testFixtureName) (used 3 times)
- should things like AllocatorUtils have there own namespace? and allocatorstats? [honestly, i think i like it the way it is..?]
- Thoughts on sizeT rather than uInt... (acc maybe not..)
- Create the MemoryCommand. If we call it something different, need to update the summary comment in HeapZone.h
	- Remember, the HeapZone should have no knwoledge of the memory command
		- Will probs have to reigster a heap zone with the memory command
			- Perhaps a macro to do this?
				- Macro can construct the heap zone and register with the supplied tag (for the heap zone scope) [we are doing it in a different way now]
- helper function to convert the memory usage to %? same with the memory layout? [nah we can do this in python, or well matplotlib can do it]
- Write a test for heap zone parent functionality. This can be done once we have an unmanged allocator or something in heap zone tests
- Heap zone parent test?
- Next up we need to write the segerated list allocator, and also do some more reading into the free list allocator design.
	- If we dont implement it (see the disseration folder on pc for notes for both coding it and disseration writeup)
	- The basic interface tests for the free list allocator (eg, allocating/freeing/usage with heapzone) will be the same for all allocators.
	  Therefore, once we have written / tested the tests perhaps package them up into a macro or something. We could do like
      NA_IMPLEMENT_ALLOCATOR_BASIC_TESTS(testFixtureName, allocType) and this would create the gTest TEST macros
      for the basic tests which we could use for all allocators. [could we?] {already did this a while back}
- MemoryCommand, heap zone scopes, memory tag scope, all this stuff.
	- For the memory tag tests, make sure the memory tag enum's type is MemoryConstant.h's MemoryTag
- Make sure you implement the other free list node implementation
	- Wasn't worth doing. See "random engine ideas" -> NA_FREE_LIST_NODE_PTRs. Sure this would have made the size smaller on x64.. but then we could run out of range.
	  Plus, its very error prone.
- Stack allocator (this way it will still work with the benchmarks, rather than a linear allocaotr)
- Add clear call to allocators..? [reset]
- Should GetMemoryLayout be in its own namespace and be debug only? [no(?) and no]
- Should defines, like NA_TRACK_ALLOCATIONS toggle if headers are included or not? eg AllocatorStats in AllocatorBase.h
	- [I think this is a slippery slope with includes and probs just not worth it. could end up with end ifs everywhere. besides, matt said not to do it i think]
- debug_[method name/var name] for debug stuff (eg heapzone getdebugname), same with test stuff? test_? [i think its ok tbh]
- Should AllocatorBase have a construtor for m_AllocatorStats? or not? (if so, remember to call it in FreeListAllocator.inl)
- Should MemoryConstants/Operators have its own folder? 
	- Still on the fence... should the Operations stuff just go in Constants?
- Thoughts on NA_ rather than NA_ [half done]
	- Would be a lot shorter, then could eg have NA_LOG_[PREP/END] w/o it being too long <-- DEFO need this. eg for the benchmark logging the file line is ugly
	- add new macros to hint
- find a fix so we dont have to reintrepret cast nulltpr and add.
	- yh defo fix this, its jank
- Remove the "test" from variables in the test scripts.. we know its tests!!
- I'm unsure how much overlap a free list allocator and segerated list allocator will have... [i think what we've got is ok]
	- I'm going to put everything for the free list under allocators/freelistallocator for now. this can be refactored later.
		- If anything is generic, it can just go in the root Allocators/ folder along with AllocatorBase
	- the same is with c_BlockAllignment. I'm doing the free list allocator first...
		- maybe this block allignment can actually be a constant inside the allocator? [DONE]
	- what about c_MinBlockSize? I've put this as an assert inside the allocator for now
- Create functions to Load/Unload BlockInfo into a struct
- Pass std::function by ref of val?
- Mark 1 arg constructros as explicit
- My first attempt is using more memory and taking more than than just malloc/free. Based off a very basic test though. [fixed this B)]
	- Though tbh, it being slower in the end doesn't really matter. Its more about anylsing *why* it is slower and profiling / comparing to
	  other allocators and research papers. This is where the marks are at!
	- Take a look at the VS profiling tools https://learn.microsoft.com/en-us/visualstudio/profiling/profiling-feature-tour?view=vs-2022
		- Make sure you make notes of any things you profile and adjust. These will probs be good in write up
	- Also just read this: https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/
		- And the other artciesl on my 300 word doc
		- That allocator is much faster than mine! Why?
- Add a parent zone functionality to heapzone? This would allow us to only do one large allocation with like a stack or linear allocator more elegantly.
- Write a test for MemoryOperations::IsAlligned. And think - should the memory allignment be different on x64 and x86?
	- Depending on the architecture, then eg the FreeList nodes will / won't fit within 8 bytes
		- Actually, this is ok because we do the if (numBytes < sizeof(FreeListNode)) check. 
	- Should this IsAlligned function take in/cast to uPtr not u32? Just cast? 
		- Therefore should c_BlockALlignment be uPtr?
- Do we need tests for utils? [No, I don't think so] What is the difference between utils and operations? [yh i know now]
- Make .hint file and add all macros
- Should we have the "Memory" folders/filters? Or should it be called something else
	- Because the whole project is just for the allocator, we dont have to bury things all inside a 'memory' folder...
		- Actually, I think that it should all be in there. do some more organisiing. Eg HeapZone folder, Alloctaor folder,
		  and I think that the Operations should also go inside the Memory parent folder
